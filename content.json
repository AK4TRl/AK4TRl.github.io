{"meta":{"title":"I'll never be him","subtitle":"所有人的坚强，都是柔软生的茧","description":"电子科技大学中山学院14级，正处于前端摸爬打滚阶段。","author":"AK4TRL","url":"//ak4trl.com"},"pages":[],"posts":[{"title":"那些有的没有的小记","slug":"note","date":"2017-05-15T09:25:32.000Z","updated":"2017-06-02T10:39:04.446Z","comments":true,"path":"2017/05/15/note/","link":"","permalink":"//ak4trl.com/2017/05/15/note/","excerpt":"随手的小记。","text":"随手的小记。 vue1.0123456789101112131415161718192021222324252627282930313233343536373839v-model一般用在表单当中，如input，textarea。&#123;&#123; $data | json &#125;&#125; 将数据json化显示。v-show 和 v-if 区别，v-show只是将css的display改成none，而v-if是直接删除。 v-on:后接方法=\"方法名字\"，其中方法名字在vue的实例methods里进行实现（另外若要阻止表单之类的进行默认动作可以在方法后面添加.prevent，或者在实例的方法里面加上e.preventDefalut。v-on:简写是@组件化开发：比如，如果我想使用两个按钮，一个用于like计数，一个用于dislike计数，我们可以用一个组件去进行重复使用。//首先我们先定义一个组件&lt;template id=\"tmp\"&gt; &lt;h1&gt;&#123;&#123; heading &#125;&#125;&lt;/h1&gt; &lt;button @click=\"count += 1\" style=\"background: &#123;&#123; color &#125;&#125;\"&gt;&#123;&#123; count &#125;&#125; &lt;/button&gt;&lt;/template&gt;//封装组件Vue.component('counter', &#123; //定义要用的组件名，在视图内可以用&lt;counter&gt;&lt;/counter&gt;这类自定义的标签 template: '#tmp', //获取组件内容 props: ['heading', 'color'], //所储存的是需要传输的数据，或者改变的量 data : function()&#123; return &#123; count : 0 &#125; &#125;&#125;);//使用&lt;counter heading=\"Likes\" color=\"green\"&gt;&lt;/counter&gt; //此处heading 和 color 的数据会传回到组件进行绑定//computed property(计算过的属性)computed: &#123; 方法名: function() &#123; &#125;&#125;//组件的事件绑定methods方法要定义到组件内。v-for=\"task in list | orderBy 'id' -1\" 官方自给的排序，每一个list都有一个id，-1是倒序，默认顺序 vue2.0123todolist删除方法2.0与1.0的区别，1.0用的.$remove()方法，2.0用的.splice(index,1)方法，index可以在数组获取v-blind:class=\"\"的两种方法1.'类名' : true 或者 false; 2.[true 或者 false ? '类名' : '类名']","categories":[],"tags":[{"name":"网站开发","slug":"网站开发","permalink":"//ak4trl.com/tags/网站开发/"},{"name":"vue","slug":"vue","permalink":"//ak4trl.com/tags/vue/"}]},{"title":"Vue + vue-cli 组件化todolist日志","slug":"vueTodolist","date":"2017-04-29T05:21:49.000Z","updated":"2017-06-02T10:54:12.020Z","comments":true,"path":"2017/04/29/vueTodolist/","link":"","permalink":"//ak4trl.com/2017/04/29/vueTodolist/","excerpt":"&emsp;&emsp;vue的核心是组件化，对于网路上各种各样的todolist，可以将todolist拆分成几个部分进行组件化，使得如若需要更改某个组件的样式的话就能直接更改组件即可。这个是链接 首先，先确定todolist可以拆分的组件。 为了添加任务，为此我们需要一个用作任务的输入框和按钮。那么我们可以将这些东西打包成一个组件，组件名为addTodo 显示添加了的任务，并能对任务是否完成进行操作。—&gt;打包组件为todoItem 将所完成的任务显示出来，并显示完成时间。—&gt;打包组件为todoItem 纵观全局，如果要清晰知道目前有多少任务的话，可以在最顶加上一个nabar将目前还没有完成的任务显示出来。—&gt;打包为nabar ps：vue-cli的安装教程已经在README给出","text":"&emsp;&emsp;vue的核心是组件化，对于网路上各种各样的todolist，可以将todolist拆分成几个部分进行组件化，使得如若需要更改某个组件的样式的话就能直接更改组件即可。这个是链接 首先，先确定todolist可以拆分的组件。 为了添加任务，为此我们需要一个用作任务的输入框和按钮。那么我们可以将这些东西打包成一个组件，组件名为addTodo 显示添加了的任务，并能对任务是否完成进行操作。—&gt;打包组件为todoItem 将所完成的任务显示出来，并显示完成时间。—&gt;打包组件为todoItem 纵观全局，如果要清晰知道目前有多少任务的话，可以在最顶加上一个nabar将目前还没有完成的任务显示出来。—&gt;打包为nabar ps：vue-cli的安装教程已经在README给出 一、添加任务（addTodo对于vue来说，创建组件文件后直接在主页进行渲染就可以了。创建addTodo.vue并进行引用，相关代码和测试如图 代码里创建了一个todos数组用于存储新添加的newtodo，当按下按钮后，将newtodo的数据传向todos，然后将todos的数据json序列化再展示出来。 在浏览器端进行添加操作，添加了三个任务，都存在于todos里面。 二、显示目前任务和已完成任务（todoItem在这个组件里，重点在于父组件与子组件间的数据传递。vue提供了props的属性，这样我们可以将数据的本体存于主页面todos.vue里面，将主页面看成父组件并向addTodo组件和todoItem组件传递数据进行操作。在主页面我们先设置两组空数组，一组todos用于储存添加的任务列表，一组hasFinish用于储存完成的任务列表。v-for对数组进行数据取出然后渲染显示。相关数据的操作。数据设置一个标记flag进行标记任务是否完成，完成的话将其反赋值，并将当前时间进行一个统计，再将新的一组带有新标记和时间的数据压入到hasFinish数组里面测试结果。","categories":[],"tags":[{"name":"网站开发","slug":"网站开发","permalink":"//ak4trl.com/tags/网站开发/"},{"name":"vue","slug":"vue","permalink":"//ak4trl.com/tags/vue/"}]},{"title":"基于 Webpack & Vue & Vue-Router 搭建小型SPA (webpack配置来源vue-cli","slug":"vue","date":"2017-04-25T18:29:56.000Z","updated":"2017-05-31T05:34:37.657Z","comments":true,"path":"2017/04/26/vue/","link":"","permalink":"//ak4trl.com/2017/04/26/vue/","excerpt":"1.环境配置安装node.js，因为相应的依赖包需要node的npm进行安装。node.js版本为6.10.2npm版本为3.10.10 123456789101112131415161718//首先先安装个淘宝镜像吧，因为对于国外的资源npm获取，某些资源用国内镜像cnpm会更快一点npm install -g cnpm --registry=https://registry.npm.taobao.org//进入所创建的工程cd /某盘/某path/某创建好的文件夹名//安装webpackcnpm(可以用npm) install webpack -g 或者 cnpm(可以用npm) install webpack （-g为全局安装一般不推荐//安装vue脚手架，如果自己搭配的话也可以试一下，不过现在为了方便npm install vue-cli -g//根据模板创建项目vue init webpack-simple 工程名字&lt;工程名字不能用中文&gt;//或者vue1.0的项目vue init webpack-simple#1.0 工程名字&lt;工程名字不能用中文&gt;然后初始化设置自己看着英文填写。 2.打开工程。目前我用的是GitHub开发的ATOM（毕竟webhub然后大概工程目录是这样的：*ps&emsp;当然，这个工程的dist文件夹和component文件夹和templates文件夹都是不存在的，生成的是一个空工程。另外component文件夹和templates文件夹是自己创建的一个用于存放component（组件）和template（模板的）的地方，dist是编译了代码后生成的。","text":"1.环境配置安装node.js，因为相应的依赖包需要node的npm进行安装。node.js版本为6.10.2npm版本为3.10.10 123456789101112131415161718//首先先安装个淘宝镜像吧，因为对于国外的资源npm获取，某些资源用国内镜像cnpm会更快一点npm install -g cnpm --registry=https://registry.npm.taobao.org//进入所创建的工程cd /某盘/某path/某创建好的文件夹名//安装webpackcnpm(可以用npm) install webpack -g 或者 cnpm(可以用npm) install webpack （-g为全局安装一般不推荐//安装vue脚手架，如果自己搭配的话也可以试一下，不过现在为了方便npm install vue-cli -g//根据模板创建项目vue init webpack-simple 工程名字&lt;工程名字不能用中文&gt;//或者vue1.0的项目vue init webpack-simple#1.0 工程名字&lt;工程名字不能用中文&gt;然后初始化设置自己看着英文填写。 2.打开工程。目前我用的是GitHub开发的ATOM（毕竟webhub然后大概工程目录是这样的：*ps&emsp;当然，这个工程的dist文件夹和component文件夹和templates文件夹都是不存在的，生成的是一个空工程。另外component文件夹和templates文件夹是自己创建的一个用于存放component（组件）和template（模板的）的地方，dist是编译了代码后生成的。 3.安装项目依赖项12//因为目前为止只是安装了相应的脚手架，而工程内的webpack设置所需要的vue-router,vue-resource,xxx-loader等等相关包还没有install下来，所以直接在包内npm install 或者 cnpm install （最好不要从国内镜像cnpm安装，会导致后面缺了很多依赖库 4.首次启动项目1先npm run build创建项目，然后npm run dev启动（ *w*），然后就能看到大大的vue标志 5.Webpack配置首先我们先看看我们的webpack设置，如果想更加详细了解webpack，可以到webpack官网了解下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: './src/main.js', //入口配置文件，主要引入vue-router路由和app.vue入口组件，其中app.vue提供了路由的挂载元素，以及通用的组件，比如header和footer什么的。其实vue的路由也是组件了，跟普通的组件并没有什么特殊。 output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'build.js' &#125;, //输出配置，path是文件输出到本地的路径，publicPath是文件的引用路径，filename是主入口的文件名。 module: &#123; rules: [ &#123;test: /\\.vue$/,loader: 'vue-loader',options: &#123;loaders: &#123;&#125; // other vue-loader options go here &#125; &#125;, &#123;test: /\\.js$/,loader: 'babel-loader',exclude: /node_modules/&#125;, &#123;test: /\\.(png|jpg|gif|svg)$/,loader: 'file-loader',options: &#123;name: '[name].[ext]?[hash]'&#125;&#125;, &#123;test: /\\.html$/,loaders: 'html-loader'&#125; ] &#125;, //模块组，不同的loaders通过正则来对不同模块文件进行处理，比如我们的vue-loader来处理.vue格式的模块。此外，html的loaders是用来处理html格式的模块的，因为目前为了学习而选择了将组件和模块分开来。后面有详细解释。 resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.js' &#125; &#125;, devServer: &#123; historyApiFallback: true, noInfo: true &#125;, performance: &#123; hints: false &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '\"production\"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; 17.5.7更新*ps&emsp;Webpack配置的话，可以把一整个划分成为三个部分。分别为: 1.webpack.base.config.js(开发和生产环境通用的配置)2.webpack.dev.config(开发环境的单独配置)3.webpack.prod.config.js(生产环境的单独配置) 6.开启Vue之旅首先我们可以看到项目已经率先给出了我们一个App.vue的模块，那么我们先用这个模块进行改造。 然后，看了App.vue里面的内容，我们大概可以知道这个模块管理着首页的展示内容，而我们打开main.js后发现这样一些内容 12345import Vue from 'vue'import App from './App.vue'const app = new Vue(&#123; render: h =&gt; h(App)&#125;).$mount('#app') 这个是直接将App.vue模块import到App内然后在首页的id为app的div里渲染出来 然后我们可以尝试一下修改工程目录下的App.vue，将内容改为1234567891011121314151617&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;&#125;&lt;/script&gt; 这是一个超级简单的实现例子，实现后是这样： 6.1第一个组件component/first.vue 在工程目录/src下创建component文件夹，并在component文件夹下创建一个 first.vue并写仿照App.vue写一个组件。 123456789101112131415&lt;template&gt; &lt;div id=\"first\"&gt; &lt;h1&gt;I am the &#123;&#123; txt &#125;&#125; component.&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/javascript\"&gt;export default &#123; data () &#123; return &#123; txt: \"first\" &#125; &#125;&#125;&lt;/script&gt; 然后在App.vue上用script将组件进行加载 12345678910111213//用import进行引入，添加到component里，并且在App.vue里，id名为app的位于&lt;template&gt;&lt;/template&gt;内的div里加上&lt;first&gt;&lt;/first&gt;&lt;script&gt;import first from './component/first.vue'export default &#123; name: 'app', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;, components: &#123; first &#125;&#125;&lt;/script&gt; 浏览器中访问： 6.2组件之间跳转vue的跳转用的不是a，而是用router-link进行对a的渲染，这时候就需要对vue-router路由进行操作 首先我们先配置好路由，修改main.js，引入并对vue-router进行注册1234567891011121314151617181920212223//配置路由规则和 app 启动配置项加上 routerimport VueRouter from \"vue-router\";import VueResource from 'vue-resource'Vue.config.debug = true;Vue.use(VueRouter);Vue.use(VueResource);//这时候我们可以直接在这个main.js的配置文件进行模块内容的引入了，因而在App.vue文件里面就不用再一次引入first了import first from './component/first.vue'//定义路由const routes = [ &#123; path : '/first', component: first&#125;//路径所在（路径可以自定义，component为内容]//创建实例const router = new VueRouter(&#123;routes&#125;)//将配置好的路由添加到Vue里面const app = new Vue(&#123; router: router, render: h =&gt; h(App)&#125;).$mount('#app') 修改App.vue的内容，将上例添加的1&lt;first&gt;&lt;/first&gt;更改为&lt;router-link to=\"/first\"&gt;点我跳转到第一个组件&lt;/router-link&gt; 运行后浏览器访问： 注意点击后的url 6.3父组件与子组件在很多情况下，组件是有父子关系的，比如 list 列表组件有个子组件 item component/item.vue 创建item.vue12345678910&lt;template&gt;&lt;p&gt;我是subitem：&#123;&#123;id&#125;&#125; - &#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script type=\"text/javascript\"&gt;export default &#123;//定义一个组的props，使用prop传递数据 props:['id','name']&#125;&lt;/script&gt; component/list.vue 创建list.vue1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;h1&gt;List&lt;/h1&gt; &lt;hr/&gt; &lt;p&gt;Hello List Page!&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"item in items\"&gt; &lt;!--用v-bind的话,每当父组件的数据变化时，该变化也会传导给子组件--&gt; &lt;!-- 这个item标签和v-bind相当于 Vue.component('item', &#123; props: ['id','name'], template: '&lt;p&gt;我是subitem：&#123;&#123;id&#125;&#125; - &#123;&#123;name&#125;&#125;&lt;/p&gt;' &#125;) 下面中，包括script内的component也是一样的情况 --&gt; &lt;item v-bind:id=\"item.id\" v-bind:name=\"item.name\"&gt;&lt;/item&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script type=\"text/javascript\"&gt;export default &#123; data : function() &#123; return &#123; items:[ &#123;\"id\":1,\"name\":\"user1\"&#125;, &#123;\"id\":2,\"name\":\"user2\"&#125; ]&#125;; &#125;, //定义item组件为子组件 //动态的Prop components:&#123; \"item\": require('../component/testItem.vue') &#125;,&#125;&lt;/script&gt; 进入main.js配置路由，进入App.vue添加一条1&lt;router-link to=\"/list\"&gt;点我跳转到父与子组件&lt;/router-link&gt;，和上一个例子一样 1234567import list from './component/list.vue'//定义路由const routes = [ &#123; path : '/first', component: first&#125;,//路径所在（路径可以自定义，component为内容 &#123; path : '/list', component: list&#125;//路径为/list，内容为引入的list.vue] 浏览器试看：点击后：子组件成功被调用 6.4组件跳转传参组件之间的跳转传参，也是一种非常常见的情况。下面为列表页，增加跳转到详情页的跳转，并传参 id 给详情页 修改路由main.js 12345const routes = [ &#123; path : '/first', component: first&#125;,//路径所在（路径可以自定义，component为内容 &#123; path : '/list', component: list&#125;,//路径为/list，内容为引入的list.vue &#123; path : '/show/:id',name:'show', component: require('./component/show')&#125;//增加详情页的跳转路由，并在路径上加上id传参，具名为name：show] 添加组件 showcomponent/show.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;h1&gt;Show&lt;/h1&gt; &lt;hr/&gt; &lt;p&gt;Hello show page!&lt;/p&gt; &lt;p&gt;id:&#123;&#123;id&#125;&#125;&lt;/p&gt; &lt;p&gt;name:&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;age:&#123;&#123;age&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script type=\"text/javascript\"&gt;export default &#123; data:function()&#123; return &#123; id:'', name:'', age:'' &#125;; &#125;, created:function()&#123; //获取params的参数ID var id=this.$route.params.id; //根据获取的参数ID，返回不同的data对象（真实业务中，这里应该是Ajax获取数据） if (id==1)&#123; this.id = id, this.age = 27, this.name = \"user1\"; &#125;else&#123; this.id = id, this.age = 25, this.name = \"user2\"; &#125; &#125;&lt;/script&gt; 修改 component/item.vue1&lt;p&gt;我是subitem： &lt;router-link :to=\"&#123;name:'show',params: &#123;id: id &#125;&#125;\"&gt; &#123;&#123;id&#125;&#125; - &#123;&#123;name&#125;&#125;&lt;/router-link&gt;&lt;/p&gt; 这里 name:‘show’ 表示具名路由路径，params 就是传参。 其中，路由传参有两种1234一种是&lt;router-link :to=\"&#123;name:'show',params: &#123;id: id &#125;&#125;\"&gt;&lt;/router-link&gt;&lt;!--路径最后变成show/id，id为所传递的参数--&gt;另一种是&lt;router-link :to=\"&#123;path:'/show',query: &#123;id: id &#125;&#125;\"&gt;&lt;/router-link&gt;&lt;!--路径最后变成show?id=x,x为所传递的参数--&gt;","categories":[],"tags":[{"name":"网站开发","slug":"网站开发","permalink":"//ak4trl.com/tags/网站开发/"},{"name":"vue","slug":"vue","permalink":"//ak4trl.com/tags/vue/"}]},{"title":"ASP.NET实训总结","slug":"ASP_NET","date":"2016-12-10T16:26:38.000Z","updated":"2017-04-28T18:18:23.959Z","comments":true,"path":"2016/12/11/ASP_NET/","link":"","permalink":"//ak4trl.com/2016/12/11/ASP_NET/","excerpt":"&emsp;&emsp;大三下学期开设的ASP.NET课程，课题经过组内讨论选择了类似K记，M记，饿了么等类似的点餐网站系统。&emsp;&emsp;开始想到的是用MVC，毕竟VS自带MVC架构模式。然后，大概是因为模型分配得不是很好，开发过程中将部分页面弄成了MVVM的模式。遇到的情况大概是在一个view内不支持多个model的传送，所以在一些需要多种数据的页面只能将一些和其他model无关联的model弄成viewModel来传输相关数据 开始的时候对MVC，MVVM这些概念都不懂，然后在学习时看的相关文章： Learn MVC Project in 7 days 谈谈UI架构设计的演化 所以，这个项目是基于MVC+MVVM模式混合，前端由Bootstrap+jQuery，后端由C#开发代码在GitHub 首页效果图","text":"&emsp;&emsp;大三下学期开设的ASP.NET课程，课题经过组内讨论选择了类似K记，M记，饿了么等类似的点餐网站系统。&emsp;&emsp;开始想到的是用MVC，毕竟VS自带MVC架构模式。然后，大概是因为模型分配得不是很好，开发过程中将部分页面弄成了MVVM的模式。遇到的情况大概是在一个view内不支持多个model的传送，所以在一些需要多种数据的页面只能将一些和其他model无关联的model弄成viewModel来传输相关数据 开始的时候对MVC，MVVM这些概念都不懂，然后在学习时看的相关文章： Learn MVC Project in 7 days 谈谈UI架构设计的演化 所以，这个项目是基于MVC+MVVM模式混合，前端由Bootstrap+jQuery，后端由C#开发代码在GitHub 首页效果图 就目前来说，能登陆，能注册，能点餐，能查看个人信息。。。就这些，详细如下图 登陆 注册 餐厅 个人中心 另外，因为开发时间很赶，因而移动端的自适应优化没有时间整理","categories":[],"tags":[{"name":"网站开发","slug":"网站开发","permalink":"//ak4trl.com/tags/网站开发/"}]},{"title":"十二月，部分的终焉","slug":"looklike","date":"2016-12-03T17:30:45.000Z","updated":"2017-04-28T09:29:50.823Z","comments":true,"path":"2016/12/04/looklike/","link":"","permalink":"//ak4trl.com/2016/12/04/looklike/","excerpt":"","text":"&emsp;&emsp; &emsp;&emsp;十二月，一年中最后一个月，所有的故事都该落下帷幕，像叶子与枝桠送别，该是尘埃落定。&emsp;&emsp;十二月，落于一年中最后一季，次年万物复苏，如世间新生命一个个的诞生，该是重生的预备。&emsp;&emsp;舞社当时收到中大珠海分校舞社的周年庆邀请时，我是有犹豫过是否要去参加的，毕竟那时候满脑子想到的都只有工作和学习，根本不敢想起其他任何事。可是，能想到，如果我不去的话，以后我会后悔的吧…毕竟在现在看来，好像以后也再也没有什么机会可以像大学这样那么多时间分配了，而且，这也可能是我在大学期间最后一次的比赛了。思前顾后了一番，最终还是选择去了。&emsp;&emsp;说起中大，大概是我一直以来的梦想吧，可是梦想都是经不起荒废之人的敲打，多么有梦想，荒废掉了也就没有了吧。现在去看看也算是圆了一个心愿，也能权当散散心。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"//ak4trl.com/tags/随笔/"}]},{"title":"Markdown Test","slug":"markdown test","date":"2016-12-01T16:01:29.000Z","updated":"2017-04-28T19:36:20.368Z","comments":true,"path":"2016/12/02/markdown test/","link":"","permalink":"//ak4trl.com/2016/12/02/markdown test/","excerpt":"","text":"这是一个普通段落： 这是一个代码区块。 代码高亮： int main() { printf(\"Hello World!\"); return 0; } 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1This is an H2任何数量的 = 和 - 都可以有效果。类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 这是 H1这是 H2 引用的区块内可以使用其他的 Markdown 语法： 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;);","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"//ak4trl.com/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-11-19T17:01:29.000Z","updated":"2017-04-28T19:35:21.272Z","comments":true,"path":"2016/11/20/hello-world/","link":"","permalink":"//ak4trl.com/2016/11/20/hello-world/","excerpt":"","text":"折腾了两天，也算是把Blog给搭建了起来。因为最近是想给自己确定一下目标，建这个Blog也就是想以此为起点，所以想着自己注册个域名，然后外加Hexo框架托管在github上弄了一个Blog。就现阶段来说，虽然说刚退了acm，可是算法什么的还是需要记下的，抽点时间我会把两年来的算法都整理一遍然后post到blog里面。 大概，这段时间发生了很多事情，让我都觉得有点措手不及了。不过，生活吧，慢慢走，慢慢过，且过且珍惜。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"//ak4trl.com/tags/杂谈/"}]}]}